\chapter{Creating a Sketch}

The most basic operation in any sketch-based modeling system is, of course, obtaining a sketch from the user.
The key characteristic of a sketch-capable input device is that it allows freehand input.
While a mouse is capable of this form of input, devices that more closely mimic the feel of freehand drawing using a pen, such as a digitizing tablet, are better for users to maximize their ability to draw.
Devices that are both an input device and a display are particularly suited to this, because it most closely mimics traditional artist creation methods by allowing direct interaction with the sketch space, as opposed to tablets where the space between the input device and the display surface is relative.
Because of this direct interaction method, it is important that our system accurately translated the user's sketch to the 3-D virtual space.
In this chapter we will discuss how we take the sketch input and create a smooth stroke that is independent of the resolution of the input device.

\section{Representation of a Sketch}

At the bare minimum, an input device should provide positional information in some two dimensional coordinate system, usually one based on the interaction window.
For sketch input, the representation must at least approximate continuous movement (Figure~\ref{fig:sampledata}).
Sampling rates vary from one device to the next.
The samples themselves may also be spaced irregularly, with sample points closer as users draw slowly or carefully, or father apart if the user draws quickly.

\begin{figure}
\label{fig:sampledata}
\fbox{\includegraphics[width=0.98\textwidth]{stroke}}
\caption{An input stroke (a) is provided to the application as (b) a sequence of point samples.}
\end{figure}

We will refer to this sampled sequence of points as a stroke. 
Strokes are stored as a list of points, objects containing coordinates from the sample space, sorted by time.
A sketch is comprised of a large number of these stroke objects.
We also support a simple layer system that can be used to segment a sketch by allowing strokes to be contained in the active layer.

\subsection{Understanding the Stroke Space}
\label{sec:samplespace}

\begin{figure}
\label{fig:samplestroke}
\centering  
\subfigure[The intended complicated stroke input onto a sensing grid.] {\label{fig:sketchintent}\includegraphics[width=.48\textwidth]{sketchinput}}
\subfigure[A potential raw input detected by the sensor.] {\label{fig:rawinput}\includegraphics[width=.48\textwidth]{rawinput}}
\caption[Sketch intent versus sketch input]{When sketching, the user's input is rasterized according to the resolution of the sensor. This makes complicated sketch input (a), difficult to understand from the limited resolution of the input (b).}
\end{figure}

Before we discuss how to create smooth strokes, we need to understand how the stroke input gets sent to the application.
When the pen touches the screen, it's position is detected by the touch panel.
This detected position is not necessarily exactly the same as the real world positions of the pen.
This is because the input is rasterized according to the resolution of the sampling device.
For example, say we are working with integer sample data, and we receive that the pen is at pixel position (148, 148).
The pen could actually be at (147.6, 148.2), or (148.2, 147.6), or any other position that samples to (148, 148) (Figure~\ref{fig:samplestroke}).
This is an issue because in our sketching application, we would like to be able to zoom in onto any surface.
This means that small errors in sampling data, and as a result, errors in spline generation, will be magnified.
While the former isn't really an issue, the latter is.


\section{Spline Curves}
\label{sec:splines}

The input data represents an approximation of the stroke input from the user that is dependent on the sample resolution of the input device, and by extension the resolution of the display.
While this would work decently well assuming we are working with a static raster image, three dimensional sketching allows the user to move the camera.
Moving the camera will eventually result in poor quality sketches from the stored stroke data lacking sub-sample rate information that accurately reflects the intent of the original stroke.
To remedy this, a mathematical representation of the curve is needed such that the "sampling rate" of the stroke is independent from the resolution of the input device.
In computer graphics, this is commonly accomplished with spline curves.

A spline is a collection of polynomial segments.
These segments can be linear, cubic, or any degree polynomial function.
Splines are a common solution for modeling smooth curves from a small number of points.
For this project, we use a Bézier curve function for the spline pieces.
A Bézier curve is a parametric curve commonly used in computer graphics to model infinitely scaling, smooth curves.
The curve is defined by control points P0, P1, ..., Pn, and is explicitly evaluated as follows:
\begin{align}
  \mathbf{B}(t) = {} &\sum_{i=0}^n {n\choose i}(1 - t)^{n - i}t^i\mathbf{P}_i \\
                = {} &(1 - t)^n\mathbf{P}_0 + {n\choose 1}(1 - t)^{n - 1}t\mathbf{P}_1 + \cdots \\
                  {} &\cdots + {n\choose n - 1}(1 - t)t^{n - 1}\mathbf{P}_{n - 1} + t^n\mathbf{P}_n,\quad 0 \le t \le 1
\end{align}
where $\scriptstyle {n \choose i}$ are the binomial coefficients, defined as
\begin{equation}
\binom nk = \binom{n-1}{k-1} + \binom{n-1}k \quad \text{for all integers }n,k : 1\le k\le n-1
\end{equation}
with initial values 
\begin{equation}
\binom n0 = \binom nn = 1 \quad \text{for all integers } n\ge0
\end{equation}
The curve can also be evaluated recursively, by
\begin{align}
\mathbf{B}_{\mathbf{P}_0}(t) = \mathbf{P}_0 \\
\mathbf{B}(t) = \mathbf{B}_{\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_n}(t) = (1-t)\mathbf{B}_{\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_{n-1}}(t) + t\mathbf{B}_{\mathbf{P}_1\mathbf{P}_2\ldots\mathbf{P}_n}(t)
\end{align}
What this equation means is that a Bezier spline of order $n$ can be defined by linear interpolation between two splines of order $n - 1$.
For this project, we will use a cubic Bézier function for the spline segments.

We must now determine a method for going from our sample data to a spline curve.
A naive approach would be to generate a spline curve that passes through the all of our control points in the order they were generated.
Any series of any four distinct points can easily be converted to a cubic Bézier curve that goes through all four points in order.
While this method guarantees that the generated curve passes through all of the input control points, it is not guaranteed to generate a curve that represents the intent of the original stroke.

\begin{center}
\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{splineartifact}
\end{center}
\caption{An example of an artifact in the spline generation caused by oddly spaced sample points.}
\label{fig:splineartifact}
\end{figure}
\begin{figure}
\begin{center}
\includegraphics[width=0.9\textwidth]{terminationbspline}
\end{center}
\caption{Using the distance from the control points for termination.}
\end{figure}
\end{center}

\subsection{Generating Splines From the Sample Data}
In theory, creating splines that are accurate to the original stroke would involve generating a curve that passes through each of the control points.
However in practice, generating a curve that is exactly the same as the input sample points is not as necessary as one would think. 
As discussed in Section~\ref{sec:samplespace}, the input data that we get is not necessarily accurate to the actual shape of the sketch.
Therefore, even if we were to create a curve that perfectly passed through all of the input points, it is possible that the output curve would still be unsatisfactory.
One common example of this is a user sketching a line diagonally through a screen.
Perfect sample data produces input in a staircase pattern, which would result in a wavy curve not representative of the intent of the original diagonal line.
Additionally, because the sample distance between points is not consistent, it is possible to produce curve with artifacts that appear unnatural upon magnification (Figure~\ref{fig:splineartifact}).
What we should actually try to accomplish with our curve generation is to match the intent of the stroke.


The approach we take is using the input samples as control points to generate a piecewise spline curve. 
This method is better at dealing with extreme changes in sample rates because the produced curve contains less convex and concave changes. 
The curve generated will also not pass through the sampled points, but if the sample rate is high, it will be close.
Using the input data as control points results in smooth reasonable curves even when the control points are far apart.
Additionally, to avoid any possible stair case sampling issues, we include a euclidean distance constraint between the sample data based on the resolution of the input. 
By manipulating the sample data this way, we are able to create curves that reasonable match the intent of the user.
However, more work can be done in the area of matching the intent of the stroke from the sample data. 

\subsection{Algorithm}

We begin with a list of control points, numbered from 0 to N-1. 
Segment i of the curve is influenced by control points i-1, i, i+1, and i+2.
Using this definition we can generate N-3 segments from the N control points without falling off the ends of the sequence.

Since we can't render a spline, we need to approximate the curve by subdividing it into small line segments.
We're going to divide each Bezier curve into a set of connected linear components, with the intent that a large enough number will look sufficiently smooth.
Subdivision of these segments occurs as follows:
\begin{enumerate}
\item Begin with points $\{P_0,P_1,P_2,P_3\}$, which define a Bézier curve, and a number $u, 0 \le u \le 1$
\item Define $L_1=(P_0 + P_1)*u$, $H=(P_1 + P_2)*u$, and $R_2=(P_2 + P_3)*u$
\item Define $L_2=(L_1 + H)*u$, and $R_1=(H + R_2)*u$
\item Define $M=(L_2 + R_1)*u$
\item Create two new Bézier curves using $\{P_0,L_1,L_2,M\}$ and $\{M,R_1,R_2,P_3\}$
\item Repeat steps 2 through 5 until a termination criteria is met. Possible criteria include distance between control points, and distance between control points $P_1$ and $P_2$ and the line between $P_0$ and $P_3$.
\end{enumerate}
If the termination criteria is small enough, then the curve will appear very smooth, even when zooming in to the curve.
This algorithm produces a smooth B-spline curve starting at control point 0 and ending at N-1.

\section{Summary}
In this section, we described how we turn user input over a set of pixel coordinates into a curve approximating the intent of the stroke.
We believe intent is more important than perfect accuracy since in practice, replicating curves that perfectly match input data results in poor quality curves.
This is because of the finite resolution of a pixel grid, where as in real world sketching, the concept of 'input resolution' does not exist.
Using a B-spline algorithm with cubic Bezier components, we can calculate a smooth spline curve for our stroke input.